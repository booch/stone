# TODO: Write a complete test suite for this class. (See my Ruby implementation/tests.)

# NOTE: A `Class` is just a `Namespace` with instances (and constructors).
# NOTE: A `Class` is also a `Function`, as it can be called with arguments (returning the result of calling its default constructor).

Boolean := Class({
    Name := "Boolean"

    # Default constructor - takes a Boolean (is effectively a no-op)
    Create :: Function[(Boolean): Boolean]  # WHOA: The type specifier in the `[]` is a Pair that requires the key to be in parens, so the parens will match with the function parameters in the function definition.
    Create := (value) => { return(value) }  # NOTE: This class has no instance fields, so the compiler should NOT allocate space for this object.

    # We're implementing Booleans using Church encoding here.
    TRUE := (t, f) => { t }
    FALSE := (t, f) => { f }

    not := (this) => { this(FALSE, TRUE) }  # NOTE: This implementation is only for languages with *strict* evaluation.
    and := (this, that) => { this(that, FALSE) }
    or := (this, that) => { this(TRUE, that) }
    xor := (this, that) => { this(not(that), that) }

    implies := (this, that) => { this(that, not(this)) }
    implied_by := (this, that) => { that(this, not(that)) }
    iff := (this, that) => { not(xor(this, that)) }  # this = antecedent, that = consequent

    if := (this, then, else) => { this(then, else) }  # TODO: This should take blocks `then` and `else`, and evaluate only the chosen block.

    as_text := (this) => { if(this, "TRUE", "FALSE") }

    all := and  # TODO: allow this to take more than 2 arguments (including `this`).
    any := or   # TODO: allow this to take more than 2 arguments (including `this`).

    logical_conjunction := and
    logical_disjunction := or
    exclusive_disjunction := xor
    material_implication := implies
    material_equivalence := iff
    tautology := (this) => { TRUE }
    contradiction := (this) => { FALSE }
    sufficient_for := implies
    necessary_for := implied_by
    necessary_and_sufficient_for := iff
    biconditional := iff
    xnor := iff

    == := iff
    != := (that) => { !(==(this, that)) }

    ¬ := not            # Unicode `not sign` character.
    ∧ := and            # Unicode `logical and` character.
    ∨ := or             # Unicode `logical or` character.
    ⊻ := xor            # Unicode `xor` character.
    ⟹ := implies        # Unicode `long rightwards double arrow` character. NOTE: This is a "wide" character in most fonts.
    ⟸ := implied_by     # Unicode `long leftwards double arrow` character.  NOTE: This is a "wide" character in most fonts.
    ⟺ := iff            # Unicode `long left right double arrow` character. NOTE: This is a "wide" character in most fonts.
    ⊤ := tautology      # Unicode `down tack` or `top` character.
    ⊥ := contradiction  # Unicode `up tack` or `bottom` character.

    ! := not
    && := and
    || := or

    × := and            # Unicode `multiplication sign` character.
    ⋅ := and            # Unicode `dot operator` character.
    * := and            # Unicode `asterisk` character.
    + := or             # Unicode `plus sign` character.
    ⊕ := xor            # Unicode `circled plus` character, the more commonly-used operator for `xor`.

    ⇒ := implies        # Unicode `rightwards double arrow` character.
    ⇐ := implied_by     # Unicode `leftwards double arrow` character.
    ⇔ := iff            # Unicode `left right double arrow` character.
    ↔ := iff            # Unicode `left right arrow` character.
    ≡ := iff            # Unicode `identical to` character.
})

### Tests

# FIXME: This is the simplest thing that could possibly (kind of) work.
# TODO: We could pass a block and run it, and print its source code.
assert := (condition) => { Boolean.if(condition, "PASSED", "FAILED")

# TODO: Might need to define `==` (which won't work with non-Booleans (Text and Integer in these tests)).

assert(Boolean.Name == "Boolean")

assert(Boolean.Create(Boolean.FALSE) == Boolean.FALSE)
assert(Boolean.Create(Boolean.TRUE) == Boolean.TRUE)

assert(Boolean.FALSE == Boolean.FALSE)
assert(Boolean.FALSE != Boolean.TRUE)
assert(Boolean.TRUE != Boolean.FALSE)
assert(Boolean.TRUE == Boolean.TRUE)

assert(Boolean.not(FALSE) == TRUE)
assert(Boolean.not(TRUE) == FALSE)

assert(Boolean.and(FALSE, FALSE) == FALSE)
assert(Boolean.and(FALSE, TRUE) == FALSE)
assert(Boolean.and(TRUE, FALSE) == FALSE)
assert(Boolean.and(TRUE, TRUE) == TRUE)

assert(Boolean.or(FALSE, FALSE) == FALSE)
assert(Boolean.or(FALSE, TRUE) == TRUE)
assert(Boolean.or(TRUE, FALSE) == TRUE)
assert(Boolean.or(TRUE, TRUE) == TRUE)

assert(Boolean.xor(FALSE, FALSE) == FALSE)
assert(Boolean.xor(FALSE, TRUE) == TRUE)
assert(Boolean.xor(TRUE, FALSE) == TRUE)
assert(Boolean.xor(TRUE, TRUE) == FALSE)

assert(Boolean.implies(FALSE, FALSE) == TRUE)
assert(Boolean.implies(FALSE, TRUE) == TRUE)
assert(Boolean.implies(TRUE, FALSE) == FALSE)
assert(Boolean.implies(TRUE, TRUE) == TRUE)

assert(Boolean.implied_by(FALSE, FALSE) == TRUE)
assert(Boolean.implied_by(FALSE, TRUE) == FALSE)
assert(Boolean.implied_by(TRUE, FALSE) == TRUE)
assert(Boolean.implied_by(TRUE, TRUE) == TRUE)

assert(Boolean.iff(FALSE, FALSE) == TRUE)
assert(Boolean.iff(FALSE, TRUE) == FALSE)
assert(Boolean.iff(TRUE, FALSE) == FALSE)
assert(Boolean.iff(TRUE, TRUE) == TRUE)

assert(Boolean.if(FALSE, 1, 2) == 2)
assert(Boolean.if(TRUE, 1, 2) == 1)


t := Boolean.TRUE
f := Boolean.FALSE

assert(f.not == TRUE)
assert(t.not == FALSE)

assert(f.and(FALSE) == FALSE)
assert(f.and(TRUE) == FALSE)
assert(t.and(FALSE) == FALSE)
assert(t.and(TRUE) == TRUE)

assert(f.or(FALSE) == FALSE)
assert(f.or(TRUE) == TRUE)
assert(t.or(FALSE) == TRUE)
assert(t.or(TRUE) == TRUE)

assert(f.xor(FALSE) == FALSE)
assert(f.xor(TRUE) == TRUE)
assert(t.xor(FALSE) == TRUE)
assert(t.xor(TRUE) == FALSE)

assert(f.implies(FALSE) == TRUE)
assert(f.implies(TRUE) == TRUE)
assert(t.implies(FALSE) == FALSE)
assert(t.implies(TRUE) == TRUE)

assert(f.implied_by(FALSE) == TRUE)
assert(f.implied_by(TRUE) == FALSE)
assert(t.implied_by(FALSE) == TRUE)
assert(t.implied_by(TRUE) == TRUE)

assert(f.iff(FALSE) == TRUE)
assert(f.iff(TRUE) == FALSE)
assert(t.iff(FALSE) == FALSE)
assert(t.iff(TRUE) == TRUE)

assert(f.if(1, 2) == 2)
assert(t.if(1, 2) == 1)
